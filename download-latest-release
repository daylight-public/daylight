#! /usr/bin/env bash

set -ux

github-curl ()
{
    # parse github args
    local -A argmap=()
    local nargs=0
    github-parse-args argmap nargs "$@"
    shift "$nargs"
    # shellcheck disable=SC2016
    (( $# >= 1 && $# <= 2 )) || { printf 'Usage: github-curl [flags] $urlPath [$urlBase]\n' >&2; return 1; }
    local urlPath=${1##/} # Trim leading slash if necessary
    local urlBase=${2:-'https://api.github.com'}

    # Set headers to flag values or default
    local acceptDefault='application/vnd.github+json'
    local accept=${argmap[accept]:-$acceptDefault}
    local outputDefault='-'
    local output=${argmap[output]:-$outputDefault}
    # Set url and token, if present
    local url="$urlBase/$urlPath"
    local token=${argmap[token]:-''}
    # Can't really parameterize on token -- we need separate curl calls for with token, and without
    if [[ -n $token ]]; then
        curl --fail-with-body \
             --location \
             --silent \
             --header "Accept: $accept" \
             --header "Authorization: Token $token" \
             --output "$output" \
             "$url" \
        || { printf 'curl failed inside github-curl\n' >&2; return 1; }
    else
        curl --fail-with-body \
             --location \
             --silent \
             --header "Accept: $accept" \
             --output "$output" \
             "$url" \
        || { printf 'curl failed inside github-curl\n' >&2; return 1; }
    fi
}

github-get-release-data ()
{
    # parse github args
    local -A argmap=()
    local nargs=0
    github-parse-args argmap nargs "$@"
    shift "$nargs"
    # shellcheck disable=SC2016
    { (( $# >= 2 )) && (( $# <= 4 )); } || { printf 'Usage: github-get-release-data [flags] $org $repo [$releaseTag [$platform]]\n' >&2; return 1; }
    local org=$1
    local repo=$2
    local tag=${3:-""}
    
    local urlPath; urlPath="$(github-get-releases-url-path "$org" "$repo" "$tag")" || return
    # build argstring for github-curl
    local argstring=''
    [[ -v argmap[token] ]] && argstring+="--token ${argmap[token]}"
    # github-curl -- note $argstring is unquoted
    github-curl $argstring "$urlPath" || return
}


github-get-releases-url-path ()
{
    # shellcheck disable=SC2016
    { (( $# >= 2 )) && (( $# <= 3 )); } || { printf 'Usage: github-get-releases-url $org $repo [$releaseTag]\n' >&2; return 1; }
    local org=$1
    local repo=$2
    local tag=${3:-""}
    
    local url
    if (( $# == 3 )) && [[ -n "$tag" ]]; then
        local url="/repos/$org/$repo/releases/tags/$tag"
    else
        local url="/repos/$org/$repo/releases/latest"
    fi
    printf '%s' "$url"
}


github-parse-args ()
{
    # shellcheck disable=SC2016
    (( $# >= 2 )) || { printf 'Usage: github-parse-args infovar nargs [$args]\n' >&2; return 1; }
    # shellcheck disable=SC2178
    [[ $1 != argmap ]] && { local -n argmap; argmap=$1; }
    # Check that argmap is either an assoc array or a nameref to an assoc array
    [[ $(declare -p argmap 2>/dev/null) == "declare -A"* ]] \
    || [[ $(declare -p "${!argmap}" 2>/dev/null) == "declare -A"* ]] \
    || { printf "%s is not an associative array, and it's not a nameref to an associative array either\n" "argmap" >&2; return 1; }
    # shellcheck disable=SC2178
    [[ $2 != nargs ]] && { local -n nargs; nargs=$2; }

    nargs=0
    shift 2
    (( $# > 0 )) || return
    while :; do
        case $1 in
            '--accept')
                (( $# >= 2 )) || { printf -- '--accept specified but no accept provided.\n' >&2; return 1; }
                argmap[accept]=$2
                ((nargs+=2))
                shift 2
                ;;
            '--output')
                (( $# >= 2 )) || { printf -- '--output specified but no output provided.\n' >&2; return 1; }
                argmap[output]=$2
                ((nargs+=2))
                shift 2
                ;;
            '--token')
                (( $# >= 2 )) || { printf -- '--token specified but no token provided.\n' >&2; return 1; }
                argmap[token]=$2
                ((nargs+=2))
                shift 2
                ;;
            '--')
                shift
                ((nargs++))
                break
                ;;
            *)
                break
                ;;
        esac
    done
}


github-list-releases ()
{
	# parse github args
	local -A argmap=()
	local nargs=0
	github-parse-args argmap nargs "$@"
	shift "$nargs"
	# shellcheck disable=SC2016
	(( $# == 2 )) || { printf 'Usage: github-list-releases [flags] $org $repo\n' >&2; return 1; }
	local org=$1
	local repo=$2

	# get release name list, using token if provided
	local argstring=''
	[[ -v argmap[token] ]] && argstring+="--token ${argmap[token]}"
	github-get-release-data $argstring "$org" "$repo" \
	| jq -r '[.assets[].name] | sort | @tsv' \
	|| return

}


github-release-get-package-data ()
{
    # shellcheck disable=SC2016
    (( $# == 3 )) || { printf 'Usage: github-release-get-package-data $org $repo $name\n' >&2; return 1; }
    local org=$1
    local repo=$2
    local name=$3

    local urlPath; urlPath="$(github-get-releases-url-path "$org" "$repo")" || return
    local tmpCurl; tmpCurl=$(mktemp --tmpdir curl.release.XXXXXX) || return
    github-curl "$urlPath" >"$tmpCurl" || return
    jq -r --arg name "$name" \
       '.assets[]
        | select(.name == $name)' \
      </"$tmpCurl" \
      || return 
}


github-release-select ()
{
	# parse github args
	local -A argmap=()
	local nargs=0
	github-parse-args argmap nargs "$@"
	shift "$nargs"
	# shellcheck disable=SC2016
	(( $# == 3 )) || { printf 'Usage: github-list-releases [flags] name $org $repo\n' >&2; return 1; }
	[[ $1 != 'name' ]] && local -n name=$1
	local org=$2
	local repo=$3

	IFS=$'\t' read -r -a names < <(github-list-releases "$org" "$repo")
	select name in "${names[@]}"; do break; done
}

github-release-download-latest ()
{
    # parse github args
    local -A argmap=()
    local nargs=0
    github-parse-args argmap nargs "$@"
    shift "$nargs"
    # shellcheck disable=SC2016
    (( $# == 4 )) || { printf 'Usage: download-latest-release $org $repo $name $downloadFolder\n' >&2; return 1; }
    local org=$1
    local repo=$2
    local name=$3
    local downloadFolder=$4

    # Get release package data as assoc array
    local -A releaseInfo
    github-get-release-package-info releaseInfo "$org" "$repo" "$name" || return
    declare -p releaseInfo
    local url=${releaseInfo[url]}
    local accept='Accept: application/octet-stream'
    local output="$downloadFolder/$name"
    local token=${argmap[token]}
    if [[ -n $token ]]; then
        github-curl --token "$token" --accept "$accept" --output "$output"
    else
        github-curl --accept "$accept" --output "$output"
    fi
    printf '%s' "$releasePath"
}

main ()
{
    # parse github args
    local -A argmap=()
    local nargs=0
    github-parse-args argmap nargs "$@"
    shift "$nargs"
    # shellcheck disable=SC2016
    (( $# == 2 )) || { printf 'Usage: download-latest-release $org $repo\n' >&2; return 1; }
    
    local org=$1
    local repo=$2
	
    local argString=""
    [[ -v argmap[token] ]] && argString+="--token ${argmap[token]}"
    local releaseName
	github-release-select $argString releaseName "$org" "$repo"
	declare -p releaseName
    local -a args=()
    read -r -a args < <(github-release-get-package-data $argString "$org" "$repo" "$releaseName" \
    | jq -r '
        [.browser_download_url,
         .content_type,
         (.browser_download_url | match(".*/(.*)").captures[0].string),
         .id,
         .name,
         .url,
         (.url | match("https://api.github.com/(.*)").captures[0].string)
        ] | @tsv' \
      || return)
    declare -p args
    local -A info=()
    info[browser_download_url]=${args[0]}
    info[content_type]=${args[1]}
    info[filename]=${args[2]}
    info[id]=${args[3]}
    info[name]=${args[4]}
    info[url]=${args[5]}
    info[urlPath]=${args[6]}
    declare -p info
    local urlPath=${info[urlPath]}
    local accept='application/octet-stream'
    local filename=${info[filename]}
    local output="/tmp/$filename"
    argString+="--accept $accept --output $output"
    github-curl $argString "$urlPath"
}

(return 0 2>/dev/null) || main "$@"
